#!/usr/bin/env python3
"""
Publish generated evidence from repo truth into MissionLog's public static folder.

MVP: Testing + Security evidence.

Testing source (generated by tools/run_story_tests.py):
  evidence/test_results/<STORY_ID>.json
Testing destination (served to MissionLog UI):
  app_frontend/public/missionlog/evidence/<STORY_ID>/testing.json

Security source (generated by tools/run_story_security.py):
  evidence/security/<STORY_ID>.json
Security destination (served to MissionLog UI):
  app_frontend/public/missionlog/evidence/<STORY_ID>/security.json

MissionLog fetches:
  /missionlog/evidence/<story_id>/<dimension>.json
Where dimensions include "testing" and "security".
"""

from __future__ import annotations

import argparse
import json
import re
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Tuple


# -----------------------------
# Repo root detection
# -----------------------------

def detect_repo_root() -> Path:
    """
    Detect repo root as the parent of the 'tools' directory.
    Matches tools/extract_MissionLog_story_defs.py behaviour.
    """
    here = Path(__file__).resolve()
    if here.parent.name != "tools":
        raise RuntimeError(
            f"Expected script to live in a 'tools' directory, but found: {here}"
        )
    return here.parent.parent


REPO_ROOT = detect_repo_root()


# -----------------------------
# Paths
# -----------------------------

TEST_SOURCE_DIR = REPO_ROOT / "evidence" / "test_results"
SECURITY_SOURCE_DIR = REPO_ROOT / "evidence" / "security"

MISSIONLOG_PUBLIC_DIR = REPO_ROOT / "app_frontend" / "public" / "missionlog"
PUBLISH_ROOT = MISSIONLOG_PUBLIC_DIR / "evidence"  # /<story_id>/<dimension>.json


# -----------------------------
# Helpers
# -----------------------------

def utc_now_iso() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def read_json(path: Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as e:
        raise RuntimeError(f"Invalid JSON in {path}: {e}") from e


def write_json(path: Path, payload: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(payload, indent=2, ensure_ascii=False) + "\n", encoding="utf-8")


def _scrub_repo_paths(obj: Any) -> Any:
    """
    Demo-safe sanitisation: remove absolute local paths from evidence payloads.
    Applied only at MissionLog extraction time.
    """
    repo_posix = REPO_ROOT.as_posix().rstrip("/")
    repo_win = str(REPO_ROOT).rstrip("\\")

    win_abs = re.compile(r"[A-Za-z]:\\[^ \n\r\t\"]+")
    repo_abs_posix = re.compile(re.escape(repo_posix) + r"(/[^ \n\r\t\"]*)?")

    if isinstance(obj, dict):
        return {k: _scrub_repo_paths(v) for k, v in obj.items()}

    if isinstance(obj, list):
        return [_scrub_repo_paths(v) for v in obj]

    if isinstance(obj, str):
        s = obj
        s = repo_abs_posix.sub("<repo>", s)
        if "\\" in s:
            s = s.replace(repo_win, "<repo>")
            s = win_abs.sub("<abs_path>", s)
        return s

    return obj


def _wrap_published(story_id: str, dimension: str, src: Path, evidence: Dict[str, Any]) -> Dict[str, Any]:
    return {
        "meta": {
            "story_id": story_id,
            "dimension": dimension,
            "published_at_utc": utc_now_iso(),
            "source_path": str(src.relative_to(REPO_ROOT)).replace("\\", "/"),
        },
        "payload": evidence,
    }


# -----------------------------
# Publish per-dimension
# -----------------------------

def publish_testing_evidence_for_story(story_id: str) -> Tuple[bool, str]:
    src = TEST_SOURCE_DIR / f"{story_id}.json"
    if not src.exists():
        return False, f"Missing testing evidence: {src.relative_to(REPO_ROOT)}"

    evidence = _scrub_repo_paths(read_json(src))
    dest = PUBLISH_ROOT / story_id / "testing.json"
    write_json(dest, _wrap_published(story_id, "testing", src, evidence))
    return True, f"Published testing evidence: {src.relative_to(REPO_ROOT)} -> {dest.relative_to(REPO_ROOT)}"


def publish_security_evidence_for_story(story_id: str) -> Tuple[bool, str]:
    src = SECURITY_SOURCE_DIR / f"{story_id}.json"
    if not src.exists():
        return False, f"Missing security evidence: {src.relative_to(REPO_ROOT)}"

    evidence = _scrub_repo_paths(read_json(src))
    dest = PUBLISH_ROOT / story_id / "security.json"
    write_json(dest, _wrap_published(story_id, "security", src, evidence))
    return True, f"Published security evidence: {src.relative_to(REPO_ROOT)} -> {dest.relative_to(REPO_ROOT)}"


def discover_story_ids() -> List[str]:
    """
    Discover story ids from any evidence source folders we support.
    """
    ids: set[str] = set()

    if TEST_SOURCE_DIR.exists():
        ids.update(p.stem for p in TEST_SOURCE_DIR.glob("ST-*.json"))

    if SECURITY_SOURCE_DIR.exists():
        ids.update(p.stem for p in SECURITY_SOURCE_DIR.glob("ST-*.json"))

    return sorted(ids)


# -----------------------------
# CLI
# -----------------------------

def main(argv: List[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Extract MissionLog evidence (testing + security).")
    g = parser.add_mutually_exclusive_group(required=True)
    g.add_argument("--story", help="Extract only this story ID (e.g., ST-05).")
    g.add_argument(
        "--all",
        action="store_true",
        help="Extract all stories that have evidence (testing and/or security).",
    )
    args = parser.parse_args(argv)

    if not MISSIONLOG_PUBLIC_DIR.exists():
        raise SystemExit(
            f"MissionLog public dir not found: {MISSIONLOG_PUBLIC_DIR.relative_to(REPO_ROOT)}"
        )

    if args.story:
        story_ids = [args.story.strip()]
    else:
        story_ids = discover_story_ids()
        if not story_ids:
            print(f"No evidence files found under { (REPO_ROOT / 'evidence').relative_to(REPO_ROOT) }")
            return 0

    ok_count = 0
    warn_count = 0

    for sid in story_ids:
        # Testing
        ok, msg = publish_testing_evidence_for_story(sid)
        if ok:
            ok_count += 1
            print(f">>> {msg}")
        else:
            warn_count += 1
            print(f"[WARN] {msg}")

        # Security
        ok, msg = publish_security_evidence_for_story(sid)
        if ok:
            ok_count += 1
            print(f">>> {msg}")
        else:
            warn_count += 1
            print(f"[WARN] {msg}")

    print(f"\nDone. Published artefacts: {ok_count}. Warnings: {warn_count}.")
    return 0 if warn_count == 0 else 2


if __name__ == "__main__":
    raise SystemExit(main())


