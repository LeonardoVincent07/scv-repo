#!/usr/bin/env python3
"""
Publish generated evidence from repo truth into MissionLog's public static folder.

MVP: Testing evidence only.

Source (generated by tools/run_story_tests.py):
  evidence/test_results/<STORY_ID>.json

Destination (served to MissionLog UI):
  app_frontend/public/missionlog/evidence/<STORY_ID>/testing.json

MissionLog fetches:
  /missionlog/evidence/<story_id>/<dimension>.json
Where dimension for Testing is "testing".
"""

from __future__ import annotations

import argparse
import json
import re
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Tuple


# -----------------------------
# Repo root detection
# -----------------------------

def detect_repo_root() -> Path:
    """
    Detect repo root as the parent of the 'tools' directory.
    Matches tools/extract_MissionLog_story_defs.py behaviour.
    """
    here = Path(__file__).resolve()
    if here.parent.name != "tools":
        raise RuntimeError(
            f"Expected script to live in a 'tools' directory, but found: {here}"
        )
    return here.parent.parent


REPO_ROOT = detect_repo_root()


# -----------------------------
# Paths (MVP: Testing only)
# -----------------------------

TEST_SOURCE_DIR = REPO_ROOT / "evidence" / "test_results"
MISSIONLOG_PUBLIC_DIR = REPO_ROOT / "app_frontend" / "public" / "missionlog"
TEST_PUBLISH_ROOT = MISSIONLOG_PUBLIC_DIR / "evidence"  # /<story_id>/testing.json


# -----------------------------
# Helpers
# -----------------------------

def utc_now_iso() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def read_json(path: Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as e:
        raise RuntimeError(f"Invalid JSON in {path}: {e}") from e


def write_json(path: Path, payload: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(payload, indent=2, ensure_ascii=False) + "\n", encoding="utf-8")


def _scrub_repo_paths(obj: Any) -> Any:
    """
    Demo-safe sanitisation: remove absolute local paths from evidence payloads.
    Applied only at MissionLog extraction time.
    """
    repo_posix = REPO_ROOT.as_posix().rstrip("/")
    repo_win = str(REPO_ROOT).rstrip("\\")

    win_abs = re.compile(r"[A-Za-z]:\\[^ \n\r\t\"]+")
    repo_abs_posix = re.compile(re.escape(repo_posix) + r"(/[^ \n\r\t\"]*)?")

    if isinstance(obj, dict):
        return {k: _scrub_repo_paths(v) for k, v in obj.items()}

    if isinstance(obj, list):
        return [_scrub_repo_paths(v) for v in obj]

    if isinstance(obj, str):
        s = obj
        s = repo_abs_posix.sub("<repo>", s)
        if "\\" in s:
            s = s.replace(repo_win, "<repo>")
            s = win_abs.sub("<abs_path>", s)
        return s

    return obj


def publish_testing_evidence_for_story(story_id: str) -> Tuple[bool, str]:
    """
    Publish evidence/test_results/<story_id>.json -> public/missionlog/evidence/<story_id>/testing.json
    Returns (ok, message).
    """
    src = TEST_SOURCE_DIR / f"{story_id}.json"
    if not src.exists():
        return False, f"Missing source evidence: {src.relative_to(REPO_ROOT)}"

    evidence = read_json(src)

    # Scrub absolute paths for demo safety (published artefact only)
    evidence = _scrub_repo_paths(evidence)

    dest = TEST_PUBLISH_ROOT / story_id / "testing.json"
    published = {
        "meta": {
            "story_id": story_id,
            "dimension": "testing",
            "published_at_utc": utc_now_iso(),
            "source_path": str(src.relative_to(REPO_ROOT)).replace("\\", "/"),
        },
        "payload": evidence,
    }

    write_json(dest, published)

    return True, (
        f"Published testing evidence: "
        f"{src.relative_to(REPO_ROOT)} -> {dest.relative_to(REPO_ROOT)}"
    )


def discover_story_ids_from_source_dir() -> List[str]:
    if not TEST_SOURCE_DIR.exists():
        return []
    ids: List[str] = []
    for p in sorted(TEST_SOURCE_DIR.glob("ST-*.json")):
        ids.append(p.stem)
    return ids


# -----------------------------
# CLI
# -----------------------------

def main(argv: List[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Publish MissionLog evidence (MVP: testing).")
    g = parser.add_mutually_exclusive_group(required=True)
    g.add_argument("--story", help="Publish only this story ID (e.g., ST-05).")
    g.add_argument(
        "--all",
        action="store_true",
        help="Publish all stories that have evidence/test_results/ST-*.json.",
    )
    args = parser.parse_args(argv)

    if not MISSIONLOG_PUBLIC_DIR.exists():
        raise SystemExit(
            f"MissionLog public dir not found: {MISSIONLOG_PUBLIC_DIR.relative_to(REPO_ROOT)}"
        )

    if args.story:
        story_ids = [args.story.strip()]
    else:
        story_ids = discover_story_ids_from_source_dir()
        if not story_ids:
            print(f"No testing evidence files found under {TEST_SOURCE_DIR.relative_to(REPO_ROOT)}")
            return 0

    ok_count = 0
    fail_count = 0

    for sid in story_ids:
        ok, msg = publish_testing_evidence_for_story(sid)
        if ok:
            ok_count += 1
            print(f">>> {msg}")
        else:
            fail_count += 1
            print(f"[WARN] {msg}")

    print(f"\nDone. Published {ok_count} story file(s). Warnings: {fail_count}.")
    return 0 if fail_count == 0 else 2


if __name__ == "__main__":
    raise SystemExit(main())

